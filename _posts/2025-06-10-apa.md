---
title: Activity Selection Problem
date: 2025-05-06 
categories: [TOP_CATEGORIE, SUB_CATEGORIE]
tags: [activity-selection-problem, greedy-algorithm, algoritma]     # TAG names should always be lowercase
---
# Activity Selection Problem ğŸš€

Hai teman-teman! Pernah gak sih kalian pusing gara-gara jadwal yang bentrok? Mau ikut acara A tapi waktunya barengan sama acara B? Atau mungkin, sebagai seorang *programmer*, kalian lagi mikirin gimana caranya bikin jadwal *resource* biar efisien banget? Nah, kalau iya, berarti kalian sudah akrab (walaupun mungkin belum kenal namanya) dengan masalah seru yang namanya **Activity Selection Problem (ASP)**!

Yuk, kita bedah tuntas bareng-bareng!

## Apa Sih Sebenarnya Activity Selection Problem Itu? ğŸ¤”

Gampangnya gini: ASP itu adalah tantangan klasik di dunia ilmu komputer di mana tugas kita adalah memilih serangkaian kegiatan yang bisa dilakukan dalam satu waktu, tapi dengan satu aturan emas: **gak boleh ada kegiatan yang tumpang tindih!** Bayangin deh, kalau kalian punya banyak tawaran kegiatan, tapi cuma bisa fokus ke satu hal dalam satu waktu, gimana caranya biar bisa ikutan kegiatan paling banyak? Nah, itu dia ASP!

### Kenapa Masalah Ini Penting Banget di Dunia Nyata? ğŸŒ

Percaya deh, masalah ini ada di mana-mana! Contohnya:

* **Jadwal Ruangan:** Kampus atau kantor punya banyak ruangan, dan banyak acara yang mau pakai. Gimana caranya biar semua ruangan terpakai optimal tanpa ada jadwal yang tabrakan?
* **Wawancara Kerja:** HRD harus menjadwalkan banyak kandidat. Kalau jadwalnya berantakan, bisa kacau semua!
* **Pengelolaan Sumber Daya:** Contohnya, mengatur penggunaan mesin di pabrik, atau slot waktu *server* biar semuanya jalan lancar.

Intinya, ASP ini membantu kita memanfaatkan waktu dan sumber daya sebaik mungkin. Keren, kan?

## Aturan Mainnya (Constraints) ğŸ˜

Agar permainan ASP ini adil, ada dua aturan utama yang wajib kita patuhi:

1. **Anti-Tabrakan Klub!** Aktivitas yang kita pilih harus punya waktu mulai yang *sama atau setelah* waktu selesai aktivitas sebelumnya.
2. **Satu Cinta, Satu Waktu!** Kita cuma bisa melakukan satu aktivitas dalam satu waktu. Gak bisa dong nge-gym sambil ikut kelas masak! ğŸ˜‚

## Kenalan dengan Si Jagoan: Algoritma Greedy! âœ¨

### Apa Itu Algoritma Greedy?

Bayangin kalian lagi belanja, terus kalian selalu milih barang yang paling murah saat itu juga, dengan harapan total belanja kalian jadi yang paling murah. Itulah esensi Greedy Algorithm! Ini adalah pendekatan yang selalu membuat keputusan terbaik *saat ini* (secara lokal), dengan harapan keputusan-keputusan kecil ini akan menghasilkan solusi terbaik secara keseluruhan (secara global).

### Kenapa Greedy Cocok Banget buat ASP?

Algoritma Greedy pas banget buat ASP karena dua alasan utama:

* **Ada Optimalitas Lokal:** Kalau kita pilih aktivitas yang selesainya paling cepat, itu akan memberikan *ruang* paling banyak untuk aktivitas lain setelahnya.
* **Solusi Global dari Keputusan Lokal:** Keputusan-keputusan "terbaik" di setiap langkah akan membentuk solusi paling optimal.

## Strategi Jitu ala Algoritma Greedy untuk ASP ğŸ¯

1. **Urutkan Dulu, Sesuai Waktu Selesai!**
2. **Pilih yang Pertama Selesai!**
3. **Lompat ke yang Gak Bentrok!**
4. **Ulangi Terus Sampai Habis!**

## Mari Berhitung! Contoh Soal Seru! ğŸ“Š

| Aktivitas | Waktu Mulai | Waktu Selesai |
| --------- | ----------- | ------------- |
| A         | 3           | 6             |
| B         | 1           | 4             |
| C         | 5           | 9             |
| D         | 8           | 10            |
| E         | 2           | 7             |

Setelah diurutkan:

| Aktivitas | Waktu Mulai | Waktu Selesai |
| --------- | ----------- | ------------- |
| B         | 1           | 4             |
| A         | 3           | 6             |
| E         | 2           | 7             |
| C         | 5           | 9             |
| D         | 8           | 10            |

Aktivitas yang terpilih: **B** dan **C**. Jadi, jumlah maksimal aktivitas yang bisa saya pilih adalah **2**.

## Latihan Seru! Yuk Coba Sendiri! ğŸ’ª

| Aktivitas | Waktu Mulai | Waktu Selesai |
| --------- | ----------- | ------------- |
| A         | 2           | 13            |
| B         | 0           | 6             |
| C         | 5           | 9             |
| D         | 8           | 11            |
| E         | 3           | 5             |
| F         | 12          | 14            |

<details>
<summary>Klik untuk melihat solusi!</summary>

### Solusi:

1. Urutkan berdasarkan waktu selesai:

   * E (3, 5)
   * B (0, 6)
   * C (5, 9)
   * D (8, 11)
   * A (2, 13)
   * F (12, 14)

2. Pilih E, lanjut ke C (mulai >= 5), lalu D (mulai >= 9), lalu F (mulai >= 11).

Aktivitas yang terpilih: **E, C, D, F**. Jumlah maksimal: **4**.

</details>

## Implementasi dengan C++ (Biar Makin Jago!) ğŸ’»

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Activity {
    int start;
    int finish;
};

bool compareActivities(Activity a, Activity b) {
    return (a.finish < b.finish);
}

void activitySelection(std::vector<Activity> activities, int n) {
    std::sort(activities.begin(), activities.end(), compareActivities);

    std::cout << "Aktivitas yang saya pilih:\n";
    int i = 0;
    std::cout << "(Start: " << activities[i].start << ", Finish: " << activities[i].finish << ")\n";

    for (int j = 1; j < n; j++) {
        if (activities[j].start >= activities[i].finish) {
            std::cout << "(Start: " << activities[j].start << ", Finish: " << activities[j].finish << ")\n";
            i = j;
        }
    }
}

int main() {
    std::vector<Activity> activities = {'{2, 13}, {0, 6}, {5, 9}, {8, 11}, {3, 5}, {12, 14}'};
    int n = activities.size();
    activitySelection(activities, n);
    return 0;
}
```

## Penutup ğŸŒŸ

Nah, sekarang kalian udah kenal banget kan sama si Activity Selection Problem ini? Semoga penjelasan ini bikin kalian makin paham dan siap menghadapi soal-soal greedy di mana pun berada!

Jangan lupa, hidup juga kadang kayak algoritma greedy: kita ambil pilihan terbaik di setiap langkah, sambil tetap lihat tujuan akhir. ğŸ˜‰



 


